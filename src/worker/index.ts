export interface Env {
  /**
   * The username to authenticate as.
   */
  USERNAME: string;
  /**
   * The content output from `compile.mjs`. This is the base64 representation of
   * the gzipped website.
   */
  ENCRYPTED_WEBSITE: string;
  /**
   * The chat ID to post notifications into.
   */
  TELEGRAM_CHAT_ID: string;
  /**
   * The telegram bot token to use for notifications.
   */
  TELEGRAM_TOKEN: string;
}

// Cloudflare webworkers only support 100k iterations.
const encryptionIterations = 100_000;

const encoder = new TextEncoder();

const base64ToBuffer = (b64: string) => Uint8Array.from(atob(b64), c => c.charCodeAt(0));

const deriveKey = (passwordKey: CryptoKey, salt: ArrayBuffer, keyUsage: string[]) =>
  crypto.subtle.deriveKey(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: encryptionIterations,
      hash: 'SHA-256',
    },
    passwordKey,
    {name: 'AES-GCM', length: 256},
    false,
    keyUsage
  );

const getPasswordKey = (password: string) =>
  crypto.subtle.importKey('raw', encoder.encode(password), 'PBKDF2', false, [
    'deriveKey',
  ]);

/**
 * Decrpyt the encrypted data generated by the compiler
 */
async function decryptData(encryptedData: string, password: string) {
  const encryptedDataBuff = base64ToBuffer(encryptedData);
  const salt = encryptedDataBuff.slice(0, 16);
  const iv = encryptedDataBuff.slice(16, 16 + 12);
  const data = encryptedDataBuff.slice(16 + 12);
  const passwordKey = await getPasswordKey(password);
  const aesKey = await deriveKey(passwordKey, salt, ['decrypt']);
  const decryptedContent = await crypto.subtle.decrypt(
    {name: 'AES-GCM', iv},
    aesKey,
    data
  );
  return decryptedContent;
}

/**
 * Return a response that requires authorization via WWW-Authenticate Basic.
 */
function reauthorize() {
  const response = new Response('Authorization Required', {status: 401});
  response.headers.set('WWW-Authenticate', 'Basic');

  return response;
}

/**
 * Send a message via telegram
 */
function notifyTelegram(env: Env, text: string) {
  const token = env.TELEGRAM_TOKEN;
  const chatId = env.TELEGRAM_CHAT_ID;

  const params = new URLSearchParams({
    text,
    chat_id: chatId,
    parse_mode: 'MarkdownV2',
  });

  try {
    return fetch(`https://api.telegram.org/bot${token}/sendMessage?${params.toString()}`);
  } catch {
    // Nothing to do if we failed
  }

  return null;
}

const handleRequest: ExportedHandlerFetchHandler<Env> = async (request, env) => {
  const authorization = request.headers.get('authorization');

  // No authorization passed, request authorization
  if (authorization === null) {
    return reauthorize();
  }

  // Extract the username and password from the authorization header
  const [username, passphrase] = atob(authorization.split(' ')[1]).split(':');

  // Invalid username
  if (username !== env.USERNAME) {
    await notifyTelegram(env, '*Recovery Website:* Invalid username attempt');
    return reauthorize();
  }

  // Attempt to decode the website with the provided passphrase
  try {
    const html = await decryptData(env.ENCRYPTED_WEBSITE, passphrase);
    const headers = new Headers([
      ['Content-Encoding', 'gzip'],
      ['Content-Type', 'text/html'],
      ['Cache-Control', 'no-store'],
    ]);

    await notifyTelegram(env, `*Recovery Website:* ACCESS GRANTED\n\nTEST`);

    return new Response(html, {status: 200, headers, encodeBody: 'manual'});
  } catch {
    // Nothing to do if we failed to decrypt
  }

  await notifyTelegram(env, '*Recovery Website:* Invalid password attempt');

  return reauthorize();
};

export default {fetch: handleRequest};
